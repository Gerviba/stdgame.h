.TH "src/linkedlist.h" 3 "Tue Dec 5 2017" "stdgame" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/linkedlist.h \- Generic type linked list (header)  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBListItem\fP"
.br
.RI "List item\&. "
.ti -1c
.RI "struct \fBLinkedList\fP"
.br
.RI "Linked list header\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBnewList\fP(x)   (\fBnewLinkedListPointer\fP(sizeof(x)))"
.br
.RI "New list 'constructor' macro for generic type\&. "
.ti -1c
.RI "#define \fBforeach\fP(it,  first)   for (it = first; it != NULL; it = it\->next)"
.br
.RI "Foreach for lists\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBListItem\fP \fBListItem\fP"
.br
.RI "List item\&. "
.ti -1c
.RI "typedef struct \fBListItem\fP * \fBIterator\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBLinkedList\fP \fBnewLinkedList\fP (size_t size)"
.br
.RI "New list value\&. "
.ti -1c
.RI "\fBLinkedList\fP * \fBnewLinkedListPointer\fP (size_t size)"
.br
.RI "New list pointer\&. "
.ti -1c
.RI "void \fBlistPush\fP (\fBLinkedList\fP *list, void *data)"
.br
.RI "Add a new list into the end of the list\&. "
.ti -1c
.RI "void * \fBlistGetValue\fP (\fBListItem\fP *it)"
.br
.RI "Returns a pointer to the value of the \fBListItem\fP\&. "
.ti -1c
.RI "void \fBlistFree\fP (\fBLinkedList\fP *list)"
.br
.RI "Free the dynamicly allocated memory\&. "
.in -1c
.SH "Detailed Description"
.PP 
Generic type linked list (header) 


.PP
\fBAuthor:\fP
.RS 4
Gerviba (Szabo Gergely) 
.RE
.PP
\fBDefinition:\fP
.RS 4
\fBlinkedlist\&.c\fP 
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define foreach(it, first)   for (it = first; it != NULL; it = it\->next)"

.PP
Foreach for lists\&. 
.PP
\fBParameters:\fP
.RS 4
\fIit\fP Iterator 
.br
\fIfirst\fP First item of the iteration 
.RE
.PP

.SS "#define newList(x)   (\fBnewLinkedListPointer\fP(sizeof(x)))"

.PP
New list 'constructor' macro for generic type\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Type of the list 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "void listFree (\fBLinkedList\fP * list)"

.PP
Free the dynamicly allocated memory\&. 
.PP
\fBNote:\fP
.RS 4
The list could not be used after calling this method\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP \fBLinkedList\fP head object 
.RE
.PP

.SS "void* listGetValue (\fBListItem\fP * it)"

.PP
Returns a pointer to the value of the \fBListItem\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP Actual item 
.RE
.PP
\fBReturns:\fP
.RS 4
Value pointer 
.RE
.PP

.SS "void listPush (\fBLinkedList\fP * list, void * data)"

.PP
Add a new list into the end of the list\&. 
.PP
\fBNote:\fP
.RS 4
The content will be copied
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP \fBLinkedList\fP head object 
.br
\fIdata\fP Pointer to the data 
.RE
.PP

.SS "\fBLinkedList\fP newLinkedList (size_t size)"

.PP
New list value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP The size of the list type 
.RE
.PP
\fBNote:\fP
.RS 4
It uses malloc, so the \fBlistFree()\fP function is required to free its values\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
Use dynamic allocated \fBnewLinkedListPointer()\fP instead\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnewLinkedListPointer()\fP 
.RE
.PP

.SS "\fBLinkedList\fP* newLinkedListPointer (size_t size)"

.PP
New list pointer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP The size of the list type 
.RE
.PP
\fBNote:\fP
.RS 4
It uses malloc, so the \fBlistFree()\fP function is required to free its values\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Dynamicly allocated linked list 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBlistFree()\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for stdgame from the source code\&.
